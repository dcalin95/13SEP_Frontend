import { ethers } from 'ethers';
import { MIND_MIRROR_NFT_ABI, MIND_MIRROR_NFT_CONFIG, IPFS_CONFIG } from '../contract/MindMirrorNFT';
import { getRobustProvider } from './rpcFallback';

/**
 * NFT Utilities for Mind Mirror NFT Contract
 */

/**
 * Upload NFT metadata and image to IPFS
 * @param {string} imageDataUrl - Canvas data URL of the NFT image
 * @param {Object} metadata - NFT metadata
 * @returns {Promise<string>} IPFS URI for the metadata
 */
export const uploadNFTToIPFS = async (imageDataUrl, metadata) => {
  try {
    console.log('üì§ Uploading NFT to IPFS...');
    
    // Convert data URL to blob
    const response = await fetch(imageDataUrl);
    const blob = await response.blob();
    
    // Create FormData for image upload
    const imageFormData = new FormData();
    imageFormData.append('file', blob, `mind-nft-${Date.now()}.png`);
    
    // Upload image to Pinata IPFS
    const imageUploadResponse = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
      method: 'POST',
      headers: {
        'pinata_api_key': IPFS_CONFIG.pinataApiKey,
        'pinata_secret_api_key': IPFS_CONFIG.pinataSecretKey
      },
      body: imageFormData
    });
    
    if (!imageUploadResponse.ok) {
      throw new Error(`Image upload failed: ${imageUploadResponse.status}`);
    }
    
    const imageResult = await imageUploadResponse.json();
    const imageIPFSUrl = `https://gateway.pinata.cloud/ipfs/${imageResult.IpfsHash}`;
    
    console.log('‚úÖ Image uploaded to IPFS:', imageIPFSUrl);
    
    // Prepare NFT metadata
    const nftMetadata = {
      name: metadata.name || `Mind Mirror NFT #${Date.now()}`,
      description: metadata.description || "Neuropsychological profile NFT generated by BitSwapDEX Mind Mirror AI",
      image: imageIPFSUrl,
      attributes: [
        {
          trait_type: "Neuropsychological Profile",
          value: metadata.neuroPsychProfile || "Basic"
        },
        {
          trait_type: "Word Count",
          value: metadata.wordCount || 0,
          display_type: "number"
        },
        {
          trait_type: "Generation Type",
          value: metadata.generationType || "AI Generated"
        },
        {
          trait_type: "Creator",
          value: metadata.creator || "BitSwapDEX User"
        },
        {
          trait_type: "Creation Date",
          value: new Date().toISOString().split('T')[0]
        }
      ],
      external_url: "https://bitswap-dex.com/mind-mirror",
      background_color: "000000"
    };
    
    // Upload metadata to IPFS
    const metadataResponse = await fetch(IPFS_CONFIG.pinataApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'pinata_api_key': IPFS_CONFIG.pinataApiKey,
        'pinata_secret_api_key': IPFS_CONFIG.pinataSecretKey
      },
      body: JSON.stringify({
        pinataContent: nftMetadata,
        pinataMetadata: {
          name: `mind-nft-metadata-${Date.now()}.json`
        }
      })
    });
    
    if (!metadataResponse.ok) {
      throw new Error(`Metadata upload failed: ${metadataResponse.status}`);
    }
    
    const metadataResult = await metadataResponse.json();
    const metadataIPFSUrl = `https://gateway.pinata.cloud/ipfs/${metadataResult.IpfsHash}`;
    
    console.log('‚úÖ Metadata uploaded to IPFS:', metadataIPFSUrl);
    
    return metadataIPFSUrl;
    
  } catch (error) {
    console.error('‚ùå IPFS upload failed:', error);
    throw error;
  }
};

/**
 * Get Mind Mirror NFT contract instance
 * @returns {Promise<ethers.Contract>}
 */
export const getMindNFTContract = async () => {
  try {
    const provider = await getRobustProvider();
    const signer = provider.getSigner();
    
    // Use testnet for now
    const contractAddress = MIND_MIRROR_NFT_CONFIG.testnet.address;
    
    if (!contractAddress || contractAddress === "0x0000000000000000000000000000000000000000") {
      throw new Error('Mind Mirror NFT contract not deployed yet');
    }
    
    return new ethers.Contract(contractAddress, MIND_MIRROR_NFT_ABI, signer);
    
  } catch (error) {
    console.error('‚ùå Failed to get NFT contract:', error);
    throw error;
  }
};

/**
 * Mint a Mind Mirror NFT
 * @param {string} recipientAddress - Address to mint the NFT to
 * @param {string} imageDataUrl - Canvas data URL of the NFT image
 * @param {Object} nftData - NFT metadata
 * @returns {Promise<Object>} Transaction result with token ID
 */
export const mintMindNFT = async (recipientAddress, imageDataUrl, nftData) => {
  try {
    console.log('üî® Starting Mind NFT minting process...');
    
    // Step 1: Upload to IPFS
    console.log('üì§ Step 1: Uploading to IPFS...');
    const metadataURI = await uploadNFTToIPFS(imageDataUrl, nftData);
    
    // Step 2: Get contract
    console.log('üìù Step 2: Getting contract instance...');
    const contract = await getMindNFTContract();
    
    // Step 3: Mint NFT
    console.log('üî® Step 3: Minting NFT on blockchain...');
    const tx = await contract.mintMindNFT(
      recipientAddress,
      metadataURI,
      nftData.neuroPsychProfile || 'basic',
      nftData.wordCount || 0
    );
    
    console.log('‚è≥ Transaction sent, waiting for confirmation...', tx.hash);
    const receipt = await tx.wait();
    
    // Extract token ID from events
    let tokenId = null;
    for (const log of receipt.logs) {
      try {
        const parsedLog = contract.interface.parseLog(log);
        if (parsedLog.name === 'MindNFTMinted') {
          tokenId = parsedLog.args.tokenId.toString();
          break;
        }
      } catch (e) {
        // Skip logs that can't be parsed
      }
    }
    
    console.log('‚úÖ Mind NFT minted successfully!');
    console.log('üÜî Token ID:', tokenId);
    console.log('üìÑ Transaction:', receipt.transactionHash);
    console.log('üåê Metadata URI:', metadataURI);
    
    return {
      success: true,
      tokenId,
      transactionHash: receipt.transactionHash,
      metadataURI,
      blockNumber: receipt.blockNumber
    };
    
  } catch (error) {
    console.error('‚ùå NFT minting failed:', error);
    throw error;
  }
};

/**
 * Transfer Mind Mirror NFT
 * @param {string} fromAddress - Current owner address
 * @param {string} toAddress - Recipient address  
 * @param {string} tokenId - Token ID to transfer
 * @returns {Promise<Object>} Transaction result
 */
export const transferMindNFT = async (fromAddress, toAddress, tokenId) => {
  try {
    console.log(`üîÑ Transferring NFT ${tokenId} from ${fromAddress} to ${toAddress}`);
    
    // Validate addresses
    if (!ethers.utils.isAddress(fromAddress) || !ethers.utils.isAddress(toAddress)) {
      throw new Error('Invalid wallet address format');
    }
    
    if (fromAddress.toLowerCase() === toAddress.toLowerCase()) {
      throw new Error('Cannot transfer to the same address');
    }
    
    // Get contract
    const contract = await getMindNFTContract();
    
    // Check ownership
    const owner = await contract.ownerOf(tokenId);
    if (owner.toLowerCase() !== fromAddress.toLowerCase()) {
      throw new Error(`You don't own NFT ${tokenId}. Current owner: ${owner}`);
    }
    
    // Execute transfer
    const tx = await contract.safeTransferFrom(fromAddress, toAddress, tokenId);
    
    console.log('‚è≥ Transfer transaction sent, waiting for confirmation...', tx.hash);
    const receipt = await tx.wait();
    
    console.log('‚úÖ NFT transferred successfully!');
    console.log('üìÑ Transaction:', receipt.transactionHash);
    
    return {
      success: true,
      transactionHash: receipt.transactionHash,
      blockNumber: receipt.blockNumber,
      from: fromAddress,
      to: toAddress,
      tokenId
    };
    
  } catch (error) {
    console.error('‚ùå NFT transfer failed:', error);
    throw error;
  }
};

/**
 * Get user's Mind Mirror NFTs
 * @param {string} userAddress - User wallet address
 * @returns {Promise<Array>} Array of NFT data
 */
export const getUserMindNFTs = async (userAddress) => {
  try {
    console.log(`üîç Getting NFTs for user: ${userAddress}`);
    
    const contract = await getMindNFTContract();
    
    // Get user's token IDs
    const tokenIds = await contract.getUserNFTs(userAddress);
    
    // Get detailed data for each NFT
    const nfts = [];
    for (const tokenId of tokenIds) {
      try {
        const tokenURI = await contract.tokenURI(tokenId);
        const mindData = await contract.getMindNFTData(tokenId);
        
        nfts.push({
          tokenId: tokenId.toString(),
          tokenURI,
          neuroPsychProfile: mindData.neuroPsychProfile,
          wordCount: mindData.wordCount.toString(),
          creationTime: new Date(mindData.creationTime.toNumber() * 1000).toISOString(),
          owner: userAddress
        });
      } catch (error) {
        console.error(`Failed to get data for token ${tokenId}:`, error);
      }
    }
    
    console.log(`‚úÖ Found ${nfts.length} NFTs for user`);
    return nfts;
    
  } catch (error) {
    console.error('‚ùå Failed to get user NFTs:', error);
    throw error;
  }
};

/**
 * Get NFT metadata from IPFS
 * @param {string} tokenURI - IPFS URI
 * @returns {Promise<Object>} NFT metadata
 */
export const getNFTMetadata = async (tokenURI) => {
  try {
    const response = await fetch(tokenURI);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error('‚ùå Failed to get NFT metadata:', error);
    throw error;
  }
};

export default {
  uploadNFTToIPFS,
  getMindNFTContract,
  mintMindNFT,
  transferMindNFT,
  getUserMindNFTs,
  getNFTMetadata
};

