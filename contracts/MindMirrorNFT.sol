// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

/**
 * @title MindMirrorNFT
 * @dev ERC-721 NFT contract for BitSwapDEX Mind Mirror neuropsychological analysis NFTs
 * Each NFT represents a unique neuropsychological profile generated by AI
 */
contract MindMirrorNFT is ERC721, ERC721URIStorage, Ownable {
    using Counters for Counters.Counter;
    
    // Token ID counter
    Counters.Counter private _tokenIdCounter;
    
    // Struct to store Mind Mirror NFT metadata
    struct MindNFTData {
        string neuroPsychProfile;  // Neuropsychological profile type
        uint256 wordCount;         // Number of words analyzed
        uint256 creationTime;      // Block timestamp when NFT was minted
        address creator;           // Address that generated the analysis
    }
    
    // Mapping from token ID to Mind NFT data
    mapping(uint256 => MindNFTData) public mindNFTData;
    
    // Mapping from user address to their NFT token IDs
    mapping(address => uint256[]) private _userNFTs;
    
    // Events
    event MindNFTMinted(
        address indexed to,
        uint256 indexed tokenId,
        string neuroPsychProfile,
        uint256 wordCount
    );
    
    event MindNFTTransferred(
        address indexed from,
        address indexed to,
        uint256 indexed tokenId
    );
    
    constructor() ERC721("BitSwapDEX Mind Mirror NFT", "MINDNFT") {
        // Start token IDs from 1
        _tokenIdCounter.increment();
    }
    
    /**
     * @dev Mint a new Mind Mirror NFT
     * @param to Address to mint the NFT to
     * @param tokenURI IPFS URI for the NFT metadata
     * @param neuroPsychProfile Type of neuropsychological profile
     * @param wordCount Number of words analyzed for personalization
     */
    function mintMindNFT(
        address to,
        string memory tokenURI,
        string memory neuroPsychProfile,
        uint256 wordCount
    ) public returns (uint256) {
        require(to != address(0), "Cannot mint to zero address");
        require(bytes(tokenURI).length > 0, "Token URI cannot be empty");
        require(bytes(neuroPsychProfile).length > 0, "Profile cannot be empty");
        
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        
        // Mint the NFT
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, tokenURI);
        
        // Store Mind NFT specific data
        mindNFTData[tokenId] = MindNFTData({
            neuroPsychProfile: neuroPsychProfile,
            wordCount: wordCount,
            creationTime: block.timestamp,
            creator: msg.sender
        });
        
        // Add to user's NFT list
        _userNFTs[to].push(tokenId);
        
        emit MindNFTMinted(to, tokenId, neuroPsychProfile, wordCount);
        
        return tokenId;
    }
    
    /**
     * @dev Get Mind NFT specific data
     * @param tokenId Token ID to query
     */
    function getMindNFTData(uint256 tokenId) public view returns (
        string memory neuroPsychProfile,
        uint256 wordCount,
        uint256 creationTime
    ) {
        require(_exists(tokenId), "Token does not exist");
        
        MindNFTData memory data = mindNFTData[tokenId];
        return (data.neuroPsychProfile, data.wordCount, data.creationTime);
    }
    
    /**
     * @dev Get all NFT token IDs owned by a user
     * @param owner Address to query
     */
    function getUserNFTs(address owner) public view returns (uint256[] memory) {
        return _userNFTs[owner];
    }
    
    /**
     * @dev Get the next token ID that will be minted
     */
    function nextTokenId() public view returns (uint256) {
        return _tokenIdCounter.current();
    }
    
    /**
     * @dev Override transfer functions to update user NFT tracking
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId,
        uint256 batchSize
    ) internal override {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
        
        // Update user NFT arrays on transfer
        if (from != address(0) && to != address(0)) {
            // Remove from sender's list
            _removeFromUserNFTs(from, tokenId);
            // Add to recipient's list
            _userNFTs[to].push(tokenId);
            
            emit MindNFTTransferred(from, to, tokenId);
        }
    }
    
    /**
     * @dev Remove token ID from user's NFT list
     */
    function _removeFromUserNFTs(address user, uint256 tokenId) private {
        uint256[] storage userTokens = _userNFTs[user];
        for (uint256 i = 0; i < userTokens.length; i++) {
            if (userTokens[i] == tokenId) {
                userTokens[i] = userTokens[userTokens.length - 1];
                userTokens.pop();
                break;
            }
        }
    }
    
    /**
     * @dev Emergency function to update user NFT tracking if needed
     */
    function updateUserNFTTracking(address user) external onlyOwner {
        delete _userNFTs[user];
        uint256 totalSupply = _tokenIdCounter.current() - 1;
        
        for (uint256 i = 1; i <= totalSupply; i++) {
            if (_exists(i) && ownerOf(i) == user) {
                _userNFTs[user].push(i);
            }
        }
    }
    
    // Override required functions
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }
    
    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) 
        returns (string memory) {
        return super.tokenURI(tokenId);
    }
    
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721URIStorage) 
        returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}

